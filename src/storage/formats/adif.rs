use std::path::PathBuf;
use std::fs;
use async_trait::async_trait;
use chrono::{DateTime, Utc, TimeZone};
use regex::Regex;
use lazy_static::lazy_static;
use thiserror::Error;

use crate::LogEntry;
use crate::storage::{Storage, StorageError, StorageFormat};

#[derive(Error, Debug)]
pub enum AdifError {
    #[error("ADIF file not found at {0}")]
    FileNotFound(PathBuf),
    
    #[error("Invalid ADIF format: {0}")]
    InvalidFormat(String),
    
    #[error("Missing required field: {0}")]
    MissingField(String),
    
    #[error("Invalid date/time format: {0}")]
    InvalidDateTime(String),
}

lazy_static! {
    static ref ADIF_FIELD_PATTERN: Regex = Regex::new(
        r"<(\w+):(\d+)(?::[A-Za-z])?>(.*?)"
    ).unwrap();
}

pub struct AdifStorage {
    path: PathBuf,
    cached_entries: Vec<LogEntry>,
}

impl AdifStorage {
    pub fn new(path: &PathBuf) -> Result<Self, StorageError> {
        let cached_entries = if path.exists() {
            let content = fs::read_to_string(path).map_err(|e| {
                StorageError::Io(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to read ADIF file: {}", e)))
            })?;
            Self::adif_to_entries(&content)?
        } else {
            // Create directory if it doesn't exist
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).map_err(|e| {
                    StorageError::Io(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to create directory: {}", e)))
                })?;
            }
            
            // Create empty ADIF file with header
            let empty_adif = Self::create_empty_adif();
            fs::write(path, &empty_adif).map_err(|e| {
                StorageError::Io(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to create empty ADIF file: {}", e)))
            })?;
            
            Vec::new()
        };

        Ok(Self {
            path: path.clone(),
            cached_entries,
        })
    }

    fn create_empty_adif() -> String {
        format!(
            "Amateur Radio Logbook\n\
            <ADIF_VER:5>3.1.4\n\
            <CREATED_TIMESTAMP:15>{}\n\
            <PROGRAMID:{}>{}\n\
            <PROGRAMVERSION:3>1.0\n\
            <EOH>\n\n",
            Utc::now().format("%Y%m%d %H%M%S"),
            "HAM_LOGBOOK".len(),
            "HAM_LOGBOOK"
        )
    }

    /// Convert ADIF string to LogEntries with improved error handling
    pub fn adif_to_entries(content: &str) -> Result<Vec<LogEntry>, StorageError> {
        let mut entries = Vec::new();
        let mut current_fields = std::collections::HashMap::new();

        // Skip header if present
        let content = if let Some(pos) = content.to_uppercase().find("<EOH>") {
            &content[pos + 5..]
        } else {
            content
        };

        for cap in ADIF_FIELD_PATTERN.captures_iter(content) {
            let field_name = cap[1].to_uppercase();
            let field_value = cap[3].to_string();

            if field_name == "EOR" {
                match Self::build_entry_from_fields(&current_fields) {
                    Some(entry) => entries.push(entry),
                    None => {
                        // Log warning but continue processing other entries
                        eprintln!("Warning: Skipped invalid ADIF record due to missing required fields");
                    }
                }
                current_fields.clear();
            } else {
                current_fields.insert(field_name, field_value);
            }
        }

        Ok(entries)
    }

    /// Convert LogEntries to ADIF string
    pub fn entries_to_adif(entries: &[LogEntry]) -> String {
        let mut adif = String::from("Generated by Amateur Radio Logbook\n<ADIF_VER:5>3.1.4\n<EOH>\n\n");
        
        for entry in entries {
            // Required fields
            adif.push_str(&format!(
                "<CALL:{}>{}\n", 
                entry.callsign.len(), 
                entry.callsign
            ));
            
            adif.push_str(&format!(
                "<QSO_DATE:10>{}\n",
                entry.timestamp.format("%Y-%m-%d")
            ));
            
            adif.push_str(&format!(
                "<TIME_ON:8>{}\n",
                entry.timestamp.format("%H%M%S")
            ));
            
            adif.push_str(&format!(
                "<FREQ:{}>{:.3}\n",
                format!("{:.3}", entry.frequency).len(),
                entry.frequency
            ));
            
            adif.push_str(&format!(
                "<MODE:{}>{}\n",
                entry.mode.len(),
                entry.mode
            ));

            // Optional fields
            if let Some(ref rst) = entry.rst_sent {
                adif.push_str(&format!("<RST_SENT:{}>{}\n", rst.len(), rst));
            }

            if let Some(ref rst) = entry.rst_received {
                adif.push_str(&format!("<RST_RCVD:{}>{}\n", rst.len(), rst));
            }

            if let Some(ref notes) = entry.notes {
                adif.push_str(&format!("<COMMENT:{}>{}\n", notes.len(), notes));
            }

            // End of record
            adif.push_str("<EOR>\n\n");
        }

        adif
    }

    fn build_entry_from_fields(fields: &std::collections::HashMap<String, String>) -> Option<LogEntry> {
        // Required fields
        let callsign = fields.get("CALL")?.clone();
        
        // Parse datetime from QSO_DATE and TIME_ON
        let date = fields.get("QSO_DATE")?;
        let binding = "000000".to_string();
        let time = fields.get("TIME_ON").unwrap_or(&binding);
        let timestamp = Self::parse_datetime(date, time).ok()?;

        // Parse frequency
        let frequency = fields.get("FREQ")
            .and_then(|f| f.parse::<f64>().ok())
            .unwrap_or(0.0);

        let mode = fields.get("MODE")?.clone();

        Some(LogEntry {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp,
            callsign,
            frequency,
            mode,
            rst_sent: fields.get("RST_SENT").cloned(),
            rst_received: fields.get("RST_RCVD").cloned(),
            notes: fields.get("COMMENT").cloned(),
            ..Default::default()
        })
    }

    fn parse_datetime(date: &str, time: &str) -> Result<DateTime<Utc>, StorageError> {
        let year: i32 = date[0..4].parse().map_err(|_| StorageError::Adif("Invalid date format".to_string()))?;
        let month: u32 = date[4..6].parse().map_err(|_| StorageError::Adif("Invalid date format".to_string()))?;
        let day: u32 = date[6..8].parse().map_err(|_| StorageError::Adif("Invalid date format".to_string()))?;
        
        let hour: u32 = time[0..2].parse().unwrap_or(0);
        let min: u32 = time[2..4].parse().unwrap_or(0);
        let sec: u32 = time[4..6].parse().unwrap_or(0);

        Utc.with_ymd_and_hms(year, month, day, hour, min, sec)
            .single()
            .ok_or_else(|| StorageError::Adif("Invalid datetime".to_string()))
    }

    fn save_to_file(&self) -> Result<(), StorageError> {
        // Write to temporary file first
        let temp_path = self.path.with_extension("adi.tmp");
        let adif = Self::entries_to_adif(&self.cached_entries);
        
        fs::write(&temp_path, &adif).map_err(|e| {
            StorageError::Io(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to write temporary file: {}", e)))
        })?;
        
        // Rename temporary file to actual file
        fs::rename(&temp_path, &self.path).map_err(|e| {
            StorageError::Io(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to save ADIF file: {}", e)))
        })?;
        
        Ok(())
    }

    pub fn backup(&self) -> Result<PathBuf, StorageError> {
        let backup_path = self.path.with_extension(format!(
            "adi.bak.{}", 
            Utc::now().format("%Y%m%d_%H%M%S")
        ));
        
        fs::copy(&self.path, &backup_path).map_err(|e| {
            StorageError::Io(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to create backup: {}", e)))
        })?;
        
        Ok(backup_path)
    }
}

#[async_trait]
impl Storage for AdifStorage {
    
    async fn save_entry(&mut self, entry: LogEntry) -> Result<(), StorageError> {
        if let Some(pos) = self.cached_entries.iter().position(|e| e.id == entry.id) {
            self.cached_entries[pos] = entry;
        } else {
            self.cached_entries.push(entry);
        }
        self.save_to_file()?;
        Ok(())
    }

    async fn add_entry(&mut self, entry: LogEntry) -> Result<(), StorageError> {
        Ok(())
    }

    async fn get_entry(&self, id: &str) -> Result<Option<LogEntry>, StorageError> {
        Ok(self.cached_entries.iter().find(|e| e.id == id).cloned())
    }

    async fn list_entries(&self) -> Result<Vec<LogEntry>, StorageError> {
        Ok(self.cached_entries.clone())
    }

    async fn update_entry(&mut self, entry: LogEntry) -> Result<(), StorageError> {
        if let Some(pos) = self.cached_entries.iter().position(|e| e.id == entry.id) {
            self.cached_entries[pos] = entry;
            self.save_to_file()?;
            Ok(())
        } else {
            Err(StorageError::Backend(format!("Entry with id {} not found", entry.id)))
        }
    }

    async fn delete_entry(&mut self, id: &str) -> Result<(), StorageError> {
        if let Some(pos) = self.cached_entries.iter().position(|e| e.id == id) {
            self.cached_entries.remove(pos);
            self.save_to_file()?;
            Ok(())
        } else {
            Err(StorageError::Backend(format!("Entry with id {} not found", id)))
        }
    }

    async fn clear(&mut self) -> Result<(), StorageError> {
        self.cached_entries.clear();
        self.save_to_file()?;
        Ok(())
    }


    fn format(&self) -> StorageFormat {
        StorageFormat::Adif
    }

    fn path(&self) -> &PathBuf {
        &self.path
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_adif_import() {
        let adif = r#"Amateur Radio Logbook
<ADIF_VER:5>3.1.4
<EOH>

<CALL:4>W1AW<QSO_DATE:8>20240327<TIME_ON:6>143000<FREQ:6>14.074<MODE:3>FT8<RST_SENT:3>599<RST_RCVD:3>599<COMMENT:9>Test entry<EOR>
"#;
        let entries = AdifStorage::adif_to_entries(adif).unwrap();
        assert_eq!(entries.len(), 1);
        
        let entry = &entries[0];
        assert_eq!(entry.callsign, "W1AW");
        assert_eq!(entry.frequency, 14.074);
        assert_eq!(entry.mode, "FT8");
        assert_eq!(entry.rst_sent.as_deref(), Some("599"));
    }

    #[tokio::test]
    async fn test_adif_export() {
        let mut entry = LogEntry::default();
        entry.callsign = "W1AW".to_string();
        entry.frequency = 14.074;
        entry.mode = "FT8".to_string();
        entry.timestamp = Utc::now();
        
        let adif = AdifStorage::entries_to_adif(&[entry]);
        assert!(adif.contains("<CALL:4>W1AW"));
        assert!(adif.contains("<MODE:3>FT8"));
        assert!(adif.contains("<EOR>"));
    }
}